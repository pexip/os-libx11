Description: fix denial of service and possible code execution via
 incorrect memory size calculations
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=56448a626fc90bcf75a1fa2f4c294b0eb1f23bd6
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=d7f04c340ade3834e603c23d543132e1ee4e0c63
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=9f5d83706543696fc944c1835a403938c06f2cc5
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=6df8a63d34b7514077188e2062a13774f920c085
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=5669a220816b7d58fcaf0c302ead16fbe5c87817
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=39515b7c3ba8cae9021bf6695e378ae19487082f
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=1f6a3dbf699b85c0ea715ef21de7e7095a714e12
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=2cd62b5eb99ffbb2fce99f3c459455e630b35bf7
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=90fd5abac2faca86f9f100353a3c9c7b89f31484
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=076428918e6c35f66b9b55c3fa097ff06496d155
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=460e8a223b87d4fa0ea1e97823e998a770e0f2a2
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=164bf4dfe839b1cc75cdeee378a243d04a8200e4
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=79d8dc08eb98842173ce239b9dd60df0e9e9ae72
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=833f6b70bc789d33607f6dbfee9e0a4178ec4b59
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=a351b8103b2ba78882e1c309e85893ca3abe2073
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=0b0f5d4358c3de7563d6af03f0d2ce454702a06a
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=192bbb9e2fc45df4e17b35b6d14ea0eb418dbd39
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b2c86b582c58f50c7b14da01cf7ebd20ef12a6b2
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=d38527e25f8b6e2f1174ecc21260c5c5416f972e
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=12ad4c6432496897ff000eb7cfecd0fb4b290331
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=3fe4bea086149f06a142a8f1d575f627ec1e22c7
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=3131740513133a9ff7cb12123d29ceb18584fc38
Origin: upstream, http://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=2820100bf8ba130b94253f415e7fa5ac28bb2037

Index: libx11-1.4.99.1/include/X11/Xlibint.h
===================================================================
--- libx11-1.4.99.1.orig/include/X11/Xlibint.h	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/include/X11/Xlibint.h	2013-05-29 16:18:48.088182372 -0400
@@ -860,6 +860,15 @@
 	struct _XExten *next_flush;	/* next in list of those with flushes */
 } _XExtension;
 
+/* Temporary definition until we can depend on an xproto release with it */
+#ifdef _X_COLD
+# define _XLIB_COLD _X_COLD
+#elif defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 403) /* 4.3+ */
+# define _XLIB_COLD __attribute__((__cold__))
+#else
+# define _XLIB_COLD /* nothing */
+#endif
+
 /* extension hooks */
 
 #ifdef DataRoutineIsProcedure
@@ -882,7 +891,14 @@
 extern void _XEatData(
     Display*		/* dpy */,
     unsigned long	/* n */
-);
+) _XLIB_COLD;
+extern void _XEatDataWords(
+    Display*		/* dpy */,
+    unsigned long	/* n */
+) _XLIB_COLD;
+#if defined(__SUNPRO_C) /* Studio compiler alternative to "cold" attribute */
+# pragma rarely_called(_XEatData, _XEatDataWords)
+#endif
 extern char *_XAllocScratch(
     Display*		/* dpy */,
     unsigned long	/* nbytes */
Index: libx11-1.4.99.1/modules/im/ximcp/Makefile.am
===================================================================
--- libx11-1.4.99.1.orig/modules/im/ximcp/Makefile.am	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/modules/im/ximcp/Makefile.am	2013-05-29 16:18:48.088182372 -0400
@@ -6,6 +6,7 @@
 	-I$(top_srcdir)/src/xcms \
 	-I$(top_srcdir)/src/xkb \
 	-I$(top_srcdir)/src/xlibi18n \
+	-I$(top_srcdir)/src \
 	-D_BSD_SOURCE -DXIM_t -DTRANS_CLIENT
 
 AM_CFLAGS= \
Index: libx11-1.4.99.1/modules/im/ximcp/imLcPrs.c
===================================================================
--- libx11-1.4.99.1.orig/modules/im/ximcp/imLcPrs.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/modules/im/ximcp/imLcPrs.c	2013-05-29 16:18:48.088182372 -0400
@@ -41,6 +41,8 @@
 #include "Ximint.h"
 #include <sys/stat.h>
 #include <stdio.h>
+#include <limits.h>
+#include "pathmax.h"
 
 #define XLC_BUFSIZE 256
 
@@ -304,9 +306,9 @@
 TransFileName(Xim im, char *name)
 {
    char *home = NULL, *lcCompose = NULL;
-   char dir[XLC_BUFSIZE];
-   char *i = name, *ret, *j;
-   int l = 0;
+   char dir[XLC_BUFSIZE] = "";
+   char *i = name, *ret = NULL, *j;
+   size_t l = 0;
 
    while (*i) {
       if (*i == '%') {
@@ -316,30 +318,51 @@
                  l++;
    	         break;
    	      case 'H':
-   	         home = getenv("HOME");
-   	         if (home)
-                     l += strlen(home);
+                 if (home == NULL)
+                     home = getenv("HOME");
+                 if (home) {
+                     size_t Hsize = strlen(home);
+                     if (Hsize > PATH_MAX)
+                         /* your home directory length is ridiculous */
+                         goto end;
+                     l += Hsize;
+                 }
    	         break;
    	      case 'L':
                  if (lcCompose == NULL)
                      lcCompose = _XlcFileName(im->core.lcd, COMPOSE_FILE);
-                 if (lcCompose)
-                     l += strlen(lcCompose);
+                 if (lcCompose) {
+                     size_t Lsize = strlen(lcCompose);
+                     if (Lsize > PATH_MAX)
+                         /* your compose pathname length is ridiculous */
+                         goto end;
+                     l += Lsize;
+                 }
    	         break;
    	      case 'S':
-                 xlocaledir(dir, XLC_BUFSIZE);
-                 l += strlen(dir);
+                 if (dir[0] == '\0')
+                     xlocaledir(dir, XLC_BUFSIZE);
+                 if (dir[0]) {
+                     size_t Ssize = strlen(dir);
+                     if (Ssize > PATH_MAX)
+                         /* your locale directory path length is ridiculous */
+                         goto end;
+                     l += Ssize;
+                 }
    	         break;
    	  }
       } else {
       	  l++;
       }
       i++;
+      if (l > PATH_MAX)
+          /* your expanded path length is ridiculous */
+          goto end;
    }
 
    j = ret = Xmalloc(l+1);
    if (ret == NULL)
-      return ret;
+      goto end;
    i = name;
    while (*i) {
       if (*i == '%') {
@@ -371,6 +394,7 @@
       }
    }
    *j = '\0';
+end:
    Xfree(lcCompose);
    return ret;
 }
@@ -674,6 +698,8 @@
 
     if (fstat (fileno (fp), &st) != -1) {
 	unsigned long size = (unsigned long) st.st_size;
+	if (st.st_size >= INT_MAX)
+	    return;
 	if (size <= sizeof tb) tbp = tb;
 	else tbp = malloc (size);
 
Index: libx11-1.4.99.1/src/Context.c
===================================================================
--- libx11-1.4.99.1.orig/src/Context.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Context.c	2013-05-29 16:18:48.092182372 -0400
@@ -111,7 +111,7 @@
     otable = db->table;
     for (i = INITHASHMASK+1; (i + i) < db->numentries; )
 	i += i;
-    db->table = (TableEntry *) Xcalloc((unsigned)i, sizeof(TableEntry));
+    db->table = Xcalloc(i, sizeof(TableEntry));
     if (!db->table) {
 	db->table = otable;
 	return;
@@ -180,11 +180,11 @@
 	UnlockDisplay(display);
     }
     if (!db) {
-	db = (DB) Xmalloc(sizeof(DBRec));
+	db = Xmalloc(sizeof(DBRec));
 	if (!db)
 	    return XCNOMEM;
 	db->mask = INITHASHMASK;
-	db->table = (TableEntry *)Xcalloc(db->mask + 1, sizeof(TableEntry));
+	db->table = Xcalloc(db->mask + 1, sizeof(TableEntry));
 	if (!db->table) {
 	    Xfree((char *)db);
 	    return XCNOMEM;
@@ -210,7 +210,7 @@
 	    return 0;
 	}
     }
-    entry = (TableEntry) Xmalloc(sizeof(TableEntryRec));
+    entry = Xmalloc(sizeof(TableEntryRec));
     if (!entry)
 	return XCNOMEM;
     entry->rid = rid;
Index: libx11-1.4.99.1/src/CrGC.c
===================================================================
--- libx11-1.4.99.1.orig/src/CrGC.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/CrGC.c	2013-05-29 16:18:48.092182372 -0400
@@ -72,7 +72,7 @@
     register _XExtension *ext;
 
     LockDisplay(dpy);
-    if ((gc = (GC)Xmalloc (sizeof(struct _XGC))) == NULL) {
+    if ((gc = Xmalloc (sizeof(struct _XGC))) == NULL) {
 	UnlockDisplay(dpy);
 	SyncHandle();
 	return (NULL);
Index: libx11-1.4.99.1/src/Depths.c
===================================================================
--- libx11-1.4.99.1.orig/src/Depths.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Depths.c	2013-05-29 16:18:48.092182372 -0400
@@ -49,7 +49,7 @@
 	register Depth *dp;
 	register int i;
 
-	depths = (int *) Xmalloc (count * sizeof(int));
+	depths = Xmalloc (count * sizeof(int));
 	if (!depths) return NULL;
 	for (i = 0, dp = scr->depths; i < count; i++, dp++)
 	  depths[i] = dp->depth;
Index: libx11-1.4.99.1/src/FSWrap.c
===================================================================
--- libx11-1.4.99.1.orig/src/FSWrap.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/FSWrap.c	2013-05-29 16:19:09.028182172 -0400
@@ -112,7 +112,7 @@
 	if (!*ptr)
 	    break;
     }
-    if (!(list = (char **) Xmalloc((unsigned)sizeof(char *) * (*num + 1)))) {
+    if (!(list = Xmalloc(sizeof(char *) * (*num + 1)))) {
 	Xfree(psave);
 	return (char **)NULL;
     }
@@ -130,10 +130,10 @@
     char **string_list_ret, **list_src, **list_dst, *dst;
     int length, count;
 
-    if (string_list == NULL || list_count == 0)
+    if (string_list == NULL || list_count <= 0)
 	return (char **) NULL;
 
-    string_list_ret = (char **) Xmalloc(sizeof(char *) * list_count);
+    string_list_ret = Xmalloc(sizeof(char *) * list_count);
     if (string_list_ret == NULL)
 	return (char **) NULL;
 
@@ -142,7 +142,7 @@
     for (length = 0; count-- > 0; list_src++)
 	length += strlen(*list_src) + 1;
 
-    dst = (char *) Xmalloc(length);
+    dst = Xmalloc(length);
     if (dst == NULL) {
 	Xfree(string_list_ret);
 	return (char **) NULL;
Index: libx11-1.4.99.1/src/Font.c
===================================================================
--- libx11-1.4.99.1.orig/src/Font.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Font.c	2013-05-29 16:18:48.092182372 -0400
@@ -31,6 +31,7 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
 
 #if defined(XF86BIGFONT) && !defined(MUSTCOPY)
 #define USE_XF86BIGFONT
@@ -183,7 +184,8 @@
     unsigned long seq)
 {
     register XFontStruct *fs;
-    register long nbytes;
+    unsigned long nbytes;
+    unsigned long reply_left; /* unused data words left in reply buffer */
     xQueryFontReply reply;
     register xResourceReq *req;
     register _XExtension *ext;
@@ -211,9 +213,10 @@
     }
     if (seq)
 	DeqAsyncHandler(dpy, &async);
-    if (! (fs = (XFontStruct *) Xmalloc (sizeof (XFontStruct)))) {
-	_XEatData(dpy, (unsigned long)(reply.nFontProps * SIZEOF(xFontProp) +
-				       reply.nCharInfos * SIZEOF(xCharInfo)));
+    reply_left = reply.length -
+	((SIZEOF(xQueryFontReply) - SIZEOF(xReply)) >> 2);
+    if (! (fs = Xmalloc (sizeof (XFontStruct)))) {
+	_XEatDataWords(dpy, reply_left);
 	return (XFontStruct *)NULL;
     }
     fs->ext_data 		= NULL;
@@ -261,16 +264,19 @@
      */
     fs->properties = NULL;
     if (fs->n_properties > 0) {
-	    nbytes = reply.nFontProps * sizeof(XFontProp);
-	    fs->properties = (XFontProp *) Xmalloc ((unsigned) nbytes);
+	    /* nFontProps is a CARD16 */
 	    nbytes = reply.nFontProps * SIZEOF(xFontProp);
+	    if ((nbytes >> 2) <= reply_left) {
+		size_t pbytes = reply.nFontProps * sizeof(XFontProp);
+		fs->properties = Xmalloc (pbytes);
+	    }
 	    if (! fs->properties) {
 		Xfree((char *) fs);
-		_XEatData(dpy, (unsigned long)
-			  (nbytes + reply.nCharInfos * SIZEOF(xCharInfo)));
+		_XEatDataWords(dpy, reply_left);
 		return (XFontStruct *)NULL;
 	    }
 	    _XRead32 (dpy, (long *)fs->properties, nbytes);
+	    reply_left -= (nbytes >> 2);
     }
     /*
      * If no characters in font, then it is a bad font, but
@@ -279,12 +285,18 @@
     /* have to unpack charinfos on some machines (CRAY) */
     fs->per_char = NULL;
     if (reply.nCharInfos > 0){
-	nbytes = reply.nCharInfos * sizeof(XCharStruct);
-	if (! (fs->per_char = (XCharStruct *) Xmalloc ((unsigned) nbytes))) {
+	/* nCharInfos is a CARD32 */
+	if (reply.nCharInfos < (INT_MAX / sizeof(XCharStruct))) {
+	    nbytes = reply.nCharInfos * SIZEOF(xCharInfo);
+	    if ((nbytes >> 2) <= reply_left) {
+		size_t cibytes = reply.nCharInfos * sizeof(XCharStruct);
+		fs->per_char = Xmalloc (cibytes);
+	    }
+	}
+	if (! fs->per_char) {
 	    if (fs->properties) Xfree((char *) fs->properties);
 	    Xfree((char *) fs);
-	    _XEatData(dpy, (unsigned long)
-			    (reply.nCharInfos * SIZEOF(xCharInfo)));
+	    _XEatDataWords(dpy, reply_left);
 	    return (XFontStruct *)NULL;
 	}
 
@@ -306,7 +318,6 @@
 	    }
 	}
 #else
-	nbytes = reply.nCharInfos * SIZEOF(xCharInfo);
 	_XRead16 (dpy, (char *)fs->per_char, nbytes);
 #endif
     }
@@ -354,7 +365,7 @@
     if (pData)
 	return (XF86BigfontCodes *) pData->private_data;
 
-    pData = (XExtData *) Xmalloc(sizeof(XExtData) + sizeof(XF86BigfontCodes));
+    pData = Xmalloc(sizeof(XExtData) + sizeof(XF86BigfontCodes));
     if (!pData) {
 	/* Out of luck. */
 	return (XF86BigfontCodes *) NULL;
@@ -434,7 +445,8 @@
     unsigned long seq)
 {
     register XFontStruct *fs;
-    register long nbytes;
+    unsigned long nbytes;
+    unsigned long reply_left; /* unused data left in reply buffer */
     xXF86BigfontQueryFontReply reply;
     register xXF86BigfontQueryFontReq *req;
     register _XExtension *ext;
@@ -487,13 +499,10 @@
     DeqAsyncHandler(dpy, &async2);
     if (seq)
 	DeqAsyncHandler(dpy, &async1);
-    if (! (fs = (XFontStruct *) Xmalloc (sizeof (XFontStruct)))) {
-	_XEatData(dpy,
-	          reply.nFontProps * SIZEOF(xFontProp)
-	          + (reply.nCharInfos > 0 && reply.shmid == (CARD32)(-1)
-	             ? reply.nUniqCharInfos * SIZEOF(xCharInfo)
-	               + (reply.nCharInfos+1)/2 * 2 * sizeof(CARD16)
-	             : 0));
+    reply_left = reply.length -
+	((SIZEOF(xXF86BigfontQueryFontReply) - SIZEOF(xReply)) >> 2);
+    if (! (fs = Xmalloc (sizeof (XFontStruct)))) {
+	_XEatDataWords(dpy, reply_left);
 	return (XFontStruct *)NULL;
     }
     fs->ext_data 		= NULL;
@@ -519,23 +528,33 @@
      */
     fs->properties = NULL;
     if (fs->n_properties > 0) {
-	nbytes = reply.nFontProps * sizeof(XFontProp);
-	fs->properties = (XFontProp *) Xmalloc ((unsigned) nbytes);
+	/* nFontProps is a CARD16 */
 	nbytes = reply.nFontProps * SIZEOF(xFontProp);
+	if ((nbytes >> 2) <= reply_left) {
+	    size_t pbytes = reply.nFontProps * sizeof(XFontProp);
+	    fs->properties = Xmalloc (pbytes);
+	}
 	if (! fs->properties) {
 	    Xfree((char *) fs);
-	    _XEatData(dpy,
-		      nbytes
-		      + (reply.nCharInfos > 0 && reply.shmid == (CARD32)(-1)
-		         ? reply.nUniqCharInfos * SIZEOF(xCharInfo)
-		           + (reply.nCharInfos+1)/2 * 2 * sizeof(CARD16)
-		         : 0));
+	    _XEatDataWords(dpy, reply_left);
 	    return (XFontStruct *)NULL;
 	}
 	_XRead32 (dpy, (long *)fs->properties, nbytes);
+	reply_left -= (nbytes >> 2);
     }
 
     fs->per_char = NULL;
+#ifndef LONG64
+    /* compares each part to half the maximum, which should be far more than
+       any real font needs, so the combined total doesn't overflow either */
+    if (reply.nUniqCharInfos > ((ULONG_MAX / 2) / SIZEOF(xCharInfo)) ||
+	reply.nCharInfos > ((ULONG_MAX / 2) / sizeof(CARD16))) {
+	Xfree((char *) fs->properties);
+	Xfree((char *) fs);
+	_XEatDataWords(dpy, reply_left);
+	return (XFontStruct *)NULL;
+    }
+#endif
     if (reply.nCharInfos > 0) {
 	/* fprintf(stderr, "received font metrics, nCharInfos = %d, nUniqCharInfos = %d, shmid = %d\n", reply.nCharInfos, reply.nUniqCharInfos, reply.shmid); */
 	if (reply.shmid == (CARD32)(-1)) {
@@ -545,18 +564,18 @@
 
 	    nbytes = reply.nUniqCharInfos * SIZEOF(xCharInfo)
 	             + (reply.nCharInfos+1)/2 * 2 * sizeof(CARD16);
-	    pUniqCI = (xCharInfo *) Xmalloc (nbytes);
+	    pUniqCI = Xmalloc (nbytes);
 	    if (!pUniqCI) {
 		if (fs->properties) Xfree((char *) fs->properties);
 		Xfree((char *) fs);
-		_XEatData(dpy, nbytes);
+		_XEatDataWords(dpy, reply_left);
 		return (XFontStruct *)NULL;
 	    }
-	    if (! (fs->per_char = (XCharStruct *) Xmalloc (reply.nCharInfos * sizeof(XCharStruct)))) {
+	    if (! (fs->per_char = Xmalloc (reply.nCharInfos * sizeof(XCharStruct)))) {
 		Xfree((char *) pUniqCI);
 		if (fs->properties) Xfree((char *) fs->properties);
 		Xfree((char *) fs);
-		_XEatData(dpy, nbytes);
+		_XEatDataWords(dpy, reply_left);
 		return (XFontStruct *)NULL;
 	    }
 	    _XRead16 (dpy, (char *) pUniqCI, nbytes);
@@ -579,7 +598,7 @@
 	    XEDataObject fs_union;
 	    char *addr;
 
-	    pData = (XExtData *) Xmalloc(sizeof(XExtData));
+	    pData = Xmalloc(sizeof(XExtData));
 	    if (!pData) {
 		if (fs->properties) Xfree((char *) fs->properties);
 		Xfree((char *) fs);
@@ -611,6 +630,7 @@
 	    if (!(extcodes->serverCapabilities & CAP_VerifiedLocal)) {
 		struct shmid_ds buf;
 		if (!(shmctl(reply.shmid, IPC_STAT, &buf) >= 0
+		      && reply.nCharInfos < (LONG_MAX / sizeof(XCharStruct))
 		      && buf.shm_segsz >= reply.shmsegoffset + reply.nCharInfos * sizeof(XCharStruct) + sizeof(CARD32)
 		      && *(CARD32 *)(addr + reply.shmsegoffset + reply.nCharInfos * sizeof(XCharStruct)) == extcodes->serverSignature)) {
 		    shmdt(addr);
Index: libx11-1.4.99.1/src/FontInfo.c
===================================================================
--- libx11-1.4.99.1.orig/src/FontInfo.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/FontInfo.c	2013-05-29 16:18:48.092182372 -0400
@@ -28,6 +28,7 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
 
 #if defined(XF86BIGFONT) && !defined(MUSTCOPY)
 #define USE_XF86BIGFONT
@@ -45,10 +46,11 @@
 int *actualCount,	/* RETURN */
 XFontStruct **info)	/* RETURN */
 {
-    register long nbytes;
+    unsigned long nbytes;
+    unsigned long reply_left;	/* unused data left in reply buffer */
     register int i;
     register XFontStruct *fs;
-    register int size = 0;
+    unsigned int size = 0;
     XFontStruct *finfo = NULL;
     char **flist = NULL;
     xListFontsWithInfoReply reply;
@@ -67,51 +69,44 @@
 	if (!_XReply (dpy, (xReply *) &reply,
 		      ((SIZEOF(xListFontsWithInfoReply) -
 			SIZEOF(xGenericReply)) >> 2), xFalse)) {
-	    for (j=(i-1); (j >= 0); j--) {
-		Xfree(flist[j]);
-		if (finfo[j].properties) Xfree((char *) finfo[j].properties);
-	    }
-	    if (flist) Xfree((char *) flist);
-	    if (finfo) Xfree((char *) finfo);
-	    UnlockDisplay(dpy);
-	    SyncHandle();
-	    return ((char **) NULL);
+	    reply.nameLength = 0; /* avoid trying to read more replies */
+	    reply_left = 0;
+	    goto badmem;
 	}
-	if (reply.nameLength == 0)
+	reply_left = reply.length -
+	    ((SIZEOF(xListFontsWithInfoReply) -	SIZEOF(xGenericReply)) >> 2);
+	if (reply.nameLength == 0) {
+	    _XEatDataWords(dpy, reply_left);
 	    break;
+	}
+	if (reply.nReplies >= (INT_MAX - i)) /* avoid overflowing size */
+	    goto badmem;
 	if ((i + reply.nReplies) >= size) {
 	    size = i + reply.nReplies + 1;
 
+	    if (size >= (INT_MAX / sizeof(XFontStruct)))
+		goto badmem;
+
 	    if (finfo) {
-		XFontStruct * tmp_finfo = (XFontStruct *)
-		    Xrealloc ((char *) finfo,
-			      (unsigned) (sizeof(XFontStruct) * size));
-		char ** tmp_flist = (char **)
-		    Xrealloc ((char *) flist,
-			      (unsigned) (sizeof(char *) * (size+1)));
-
-		if ((! tmp_finfo) || (! tmp_flist)) {
-		    /* free all the memory that we allocated */
-		    for (j=(i-1); (j >= 0); j--) {
-			Xfree(flist[j]);
-			if (finfo[j].properties)
-			    Xfree((char *) finfo[j].properties);
-		    }
-		    if (tmp_flist) Xfree((char *) tmp_flist);
-		    else Xfree((char *) flist);
-		    if (tmp_finfo) Xfree((char *) tmp_finfo);
-		    else Xfree((char *) finfo);
-		    goto clearwire;
-		}
-		finfo = tmp_finfo;
-		flist = tmp_flist;
+		XFontStruct * tmp_finfo;
+		char ** tmp_flist;
+
+		tmp_finfo = Xrealloc (finfo, sizeof(XFontStruct) * size);
+		if (tmp_finfo)
+		    finfo = tmp_finfo;
+		else
+		    goto badmem;
+
+		tmp_flist = Xrealloc (flist, sizeof(char *) * (size+1));
+		if (tmp_flist)
+		    flist = tmp_flist;
+		else
+		    goto badmem;
 	    }
 	    else {
-		if (! (finfo = (XFontStruct *)
-		       Xmalloc((unsigned) (sizeof(XFontStruct) * size))))
+		if (! (finfo = Xmalloc(sizeof(XFontStruct) * size)))
 		    goto clearwire;
-		if (! (flist = (char **)
-		       Xmalloc((unsigned) (sizeof(char *) * (size+1))))) {
+		if (! (flist = Xmalloc(sizeof(char *) * (size+1)))) {
 		    Xfree((char *) finfo);
 		    goto clearwire;
 		}
@@ -159,24 +154,27 @@
 #endif /* MUSTCOPY */
 
 	fs->n_properties = reply.nFontProps;
+	fs->properties = NULL;
 	if (fs->n_properties > 0) {
-	    nbytes = reply.nFontProps * sizeof(XFontProp);
-	    if (! (fs->properties = (XFontProp *) Xmalloc((unsigned) nbytes)))
-		goto badmem;
+	    /* nFontProps is a CARD16 */
 	    nbytes = reply.nFontProps * SIZEOF(xFontProp);
+	    if ((nbytes >> 2) <= reply_left) {
+		size_t pbytes = reply.nFontProps * sizeof(XFontProp);
+		fs->properties = Xmalloc (pbytes);
+	    }
+	    if (! fs->properties)
+		goto badmem;
 	    _XRead32 (dpy, (long *)fs->properties, nbytes);
+	    reply_left -= (nbytes >> 2);
+	}
 
-	} else
-	    fs->properties = NULL;
-
-	j = reply.nameLength + 1;
+	/* nameLength is a CARD8 */
+	nbytes = reply.nameLength + 1;
 	if (!i)
-	    j++; /* make first string 1 byte longer, to match XListFonts */
-	flist[i] = (char *) Xmalloc ((unsigned int) j);
+	    nbytes++; /* make first string 1 byte longer, to match XListFonts */
+	flist[i] = Xmalloc (nbytes);
 	if (! flist[i]) {
 	    if (finfo[i].properties) Xfree((char *) finfo[i].properties);
-	    nbytes = (reply.nameLength + 3) & ~3;
-	    _XEatData(dpy, (unsigned long) nbytes);
 	    goto badmem;
 	}
 	if (!i) {
@@ -198,27 +196,25 @@
   badmem:
     /* Free all memory allocated by this function. */
     for (j=(i-1); (j >= 0); j--) {
-	Xfree(flist[j]);
-	if (finfo[j].properties) Xfree((char *) finfo[j].properties);
+        if (j == 0)
+            flist[j]--;         /* was incremented above */
+        Xfree(flist[j]);
+        if (finfo[j].properties) Xfree((char *) finfo[j].properties);
     }
     if (flist) Xfree((char *) flist);
     if (finfo) Xfree((char *) finfo);
 
   clearwire:
     /* Clear the wire. */
-    do {
-	if (reply.nFontProps)
-	    _XEatData(dpy, (unsigned long)
-		      (reply.nFontProps * SIZEOF(xFontProp)));
-	nbytes = (reply.nameLength + 3) & ~3;
-	_XEatData(dpy, (unsigned long) nbytes);
-    }
-    while (_XReply(dpy,(xReply *) &reply, ((SIZEOF(xListFontsWithInfoReply) -
-					    SIZEOF(xGenericReply)) >> 2),
-		   xFalse) && (reply.nameLength != 0));
-
+    _XEatDataWords(dpy, reply_left);
+    while ((reply.nameLength != 0) &&
+	   _XReply(dpy, (xReply *) &reply,
+		   ((SIZEOF(xListFontsWithInfoReply) - SIZEOF(xGenericReply))
+		    >> 2), xTrue));
     UnlockDisplay(dpy);
     SyncHandle();
+    *info = NULL;
+    *actualCount = 0;
     return (char **) NULL;
 }
 
Index: libx11-1.4.99.1/src/GetAtomNm.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetAtomNm.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetAtomNm.c	2013-05-29 16:18:48.092182372 -0400
@@ -46,7 +46,7 @@
 	for (idx = TABLESIZE; --idx >= 0; ) {
 	    if ((e = *table++) && (e->atom == atom)) {
 		idx = strlen(EntryName(e)) + 1;
-		if ((name = (char *)Xmalloc(idx)))
+		if ((name = Xmalloc(idx)))
 		    strcpy(name, EntryName(e));
 		return name;
 	    }
@@ -73,12 +73,12 @@
 	SyncHandle();
 	return(NULL);
     }
-    if ((name = (char *) Xmalloc(rep.nameLength+1))) {
+    if ((name = Xmalloc(rep.nameLength + 1))) {
 	_XReadPad(dpy, name, (long)rep.nameLength);
 	name[rep.nameLength] = '\0';
 	_XUpdateAtomCache(dpy, name, atom, 0, -1, 0);
     } else {
-	_XEatData(dpy, (unsigned long) (rep.nameLength + 3) & ~3);
+	_XEatDataWords(dpy, rep.length);
 	name = (char *) NULL;
     }
     UnlockDisplay(dpy);
@@ -124,7 +124,7 @@
 	_XGetAsyncReply(dpy, (char *)&replbuf, rep, buf, len,
 			(SIZEOF(xGetAtomNameReply) - SIZEOF(xReply)) >> 2,
 			False);
-    state->names[state->idx] = (char *) Xmalloc(repl->nameLength+1);
+    state->names[state->idx] = Xmalloc(repl->nameLength + 1);
     _XGetAsyncData(dpy, state->names[state->idx], buf, len,
 		   SIZEOF(xGetAtomNameReply), repl->nameLength,
 		   repl->length << 2);
@@ -170,13 +170,13 @@
     }
     if (missed >= 0) {
 	if (_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
-	    if ((names_return[missed] = (char *) Xmalloc(rep.nameLength+1))) {
+	    if ((names_return[missed] = Xmalloc(rep.nameLength + 1))) {
 		_XReadPad(dpy, names_return[missed], (long)rep.nameLength);
 		names_return[missed][rep.nameLength] = '\0';
 		_XUpdateAtomCache(dpy, names_return[missed], atoms[missed],
 				  0, -1, 0);
 	    } else {
-		_XEatData(dpy, (unsigned long) (rep.nameLength + 3) & ~3);
+		_XEatDataWords(dpy, rep.length);
 		async_state.status = 0;
 	    }
 	}
Index: libx11-1.4.99.1/src/GetDflt.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetDflt.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetDflt.c	2013-05-29 16:18:48.092182372 -0400
@@ -52,30 +52,7 @@
 #include "Xlibint.h"
 #include <X11/Xos.h>
 #include <X11/Xresource.h>
-
-#ifndef X_NOT_POSIX
-#ifdef _POSIX_SOURCE
-#include <limits.h>
-#else
-#define _POSIX_SOURCE
-#include <limits.h>
-#undef _POSIX_SOURCE
-#endif
-#endif
-#ifndef PATH_MAX
-#ifdef WIN32
-#define PATH_MAX 512
-#else
-#include <sys/param.h>
-#endif
-#ifndef PATH_MAX
-#ifdef MAXPATHLEN
-#define PATH_MAX MAXPATHLEN
-#else
-#define PATH_MAX 1024
-#endif
-#endif
-#endif
+#include "pathmax.h"
 
 #ifdef XTHREADS
 #include <X11/Xthreads.h>
Index: libx11-1.4.99.1/src/GetHints.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetHints.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetHints.c	2013-05-29 16:18:48.092182372 -0400
@@ -128,7 +128,7 @@
                 return(NULL);
 		}
 	/* static copies not allowed in library, due to reentrancy constraint*/
-	if ((hints = (XWMHints *) Xcalloc (1, (unsigned) sizeof(XWMHints)))) {
+	if ((hints = Xcalloc (1, sizeof(XWMHints)))) {
 	    hints->flags = prop->flags;
 	    hints->input = (prop->input ? True : False);
 	    hints->initial_state = cvtINT32toInt (prop->initialState);
@@ -203,8 +203,7 @@
 	/* static copies not allowed in library, due to reentrancy constraint*/
 
 	nitems /= NumPropIconSizeElements;
-	if (! (hp = hints = (XIconSize *)
-	  Xcalloc ((unsigned) nitems, (unsigned) sizeof(XIconSize)))) {
+	if (! (hp = hints = Xcalloc (nitems, sizeof(XIconSize)))) {
 	    if (prop) Xfree ((char *) prop);
 	    return 0;
 	}
@@ -317,14 +316,14 @@
 
    if ( (actual_type == XA_STRING) && (actual_format == 8) ) {
 	len_name = strlen((char *) data);
-	if (! (classhint->res_name = Xmalloc((unsigned) (len_name+1)))) {
+	if (! (classhint->res_name = Xmalloc(len_name + 1))) {
 	    Xfree((char *) data);
 	    return (0);
 	}
 	strcpy(classhint->res_name, (char *) data);
 	if (len_name == nitems) len_name--;
 	len_class = strlen((char *) (data+len_name+1));
-	if (! (classhint->res_class = Xmalloc((unsigned) (len_class+1)))) {
+	if (! (classhint->res_class = Xmalloc(len_class + 1))) {
 	    Xfree(classhint->res_name);
 	    classhint->res_name = (char *) NULL;
 	    Xfree((char *) data);
Index: libx11-1.4.99.1/src/GetImage.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetImage.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetImage.c	2013-05-29 16:18:48.092182372 -0400
@@ -30,6 +30,7 @@
 #include "Xlibint.h"
 #include <X11/Xutil.h>		/* for XDestroyImage */
 #include "ImUtil.h"
+#include <limits.h>
 
 #define ROUNDUP(nbytes, pad) (((((nbytes) - 1) + (pad)) / (pad)) * (pad))
 
@@ -56,7 +57,7 @@
 	xGetImageReply rep;
 	register xGetImageReq *req;
 	char *data;
-	long nbytes;
+	unsigned long nbytes;
 	XImage *image;
 	LockDisplay(dpy);
 	GetReq (GetImage, req);
@@ -78,10 +79,13 @@
 		return (XImage *)NULL;
 	}
 
-	nbytes = (long)rep.length << 2;
-	data = (char *) Xmalloc((unsigned) nbytes);
+	if (rep.length < (INT_MAX >> 2)) {
+	    nbytes = (unsigned long)rep.length << 2;
+	    data = Xmalloc(nbytes);
+	} else
+	    data = NULL;
 	if (! data) {
-	    _XEatData(dpy, (unsigned long) nbytes);
+	    _XEatDataWords(dpy, rep.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return (XImage *) NULL;
Index: libx11-1.4.99.1/src/GetMoEv.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetMoEv.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetMoEv.c	2013-05-29 16:18:48.092182372 -0400
@@ -28,6 +28,7 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
 
 XTimeCoord *XGetMotionEvents(
     register Display *dpy,
@@ -39,7 +40,6 @@
     xGetMotionEventsReply rep;
     register xGetMotionEventsReq *req;
     XTimeCoord *tc = NULL;
-    long nbytes;
     LockDisplay(dpy);
     GetReq(GetMotionEvents, req);
     req->window = w;
@@ -52,26 +52,22 @@
 	return (NULL);
 	}
 
-    if (rep.nEvents) {
-	if (! (tc = (XTimeCoord *)
-	       Xmalloc( (unsigned)
-		       (nbytes = (long) rep.nEvents * sizeof(XTimeCoord))))) {
-	    _XEatData (dpy, (unsigned long) nbytes);
-	    UnlockDisplay(dpy);
-	    SyncHandle();
-	    return (NULL);
-	}
+    if (rep.nEvents && (rep.nEvents < (INT_MAX / sizeof(XTimeCoord))))
+	tc = Xmalloc(rep.nEvents * sizeof(XTimeCoord));
+    if (tc == NULL) {
+	/* server returned either no events or a bad event count */
+	*nEvents = 0;
+	_XEatDataWords (dpy, rep.length);
     }
-
-    *nEvents = rep.nEvents;
-    nbytes = SIZEOF (xTimecoord);
+    else
     {
 	register XTimeCoord *tcptr;
-	register int i;
+	unsigned int i;
 	xTimecoord xtc;
 
+	*nEvents = (int) rep.nEvents;
 	for (i = rep.nEvents, tcptr = tc; i > 0; i--, tcptr++) {
-	    _XRead (dpy, (char *) &xtc, nbytes);
+	    _XRead (dpy, (char *) &xtc, SIZEOF (xTimecoord));
 	    tcptr->time = xtc.time;
 	    tcptr->x    = cvtINT16toShort (xtc.x);
 	    tcptr->y    = cvtINT16toShort (xtc.y);
Index: libx11-1.4.99.1/src/GetPntMap.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetPntMap.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetPntMap.c	2013-05-29 16:18:48.092182372 -0400
@@ -29,6 +29,7 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
 
 #ifdef MIN		/* some systems define this in <sys/param.h> */
 #undef MIN
@@ -42,7 +43,7 @@
 
 {
     unsigned char mapping[256];	/* known fixed size */
-    long nbytes, remainder = 0;
+    unsigned long nbytes, remainder = 0;
     xGetPointerMappingReply rep;
     register xReq *req;
 
@@ -54,9 +55,15 @@
 	return 0;
     }
 
-    nbytes = (long)rep.length << 2;
-
     /* Don't count on the server returning a valid value */
+    if (rep.length >= (INT_MAX >> 2)) {
+	_XEatDataWords(dpy, rep.length);
+	UnlockDisplay(dpy);
+	SyncHandle();
+	return 0;
+    }
+
+    nbytes = (unsigned long) rep.length << 2;
     if (nbytes > sizeof mapping) {
 	remainder = nbytes - sizeof mapping;
 	nbytes = sizeof mapping;
@@ -69,7 +76,7 @@
 	}
 
     if (remainder)
-	_XEatData(dpy, (unsigned long)remainder);
+	_XEatData(dpy, remainder);
 
     UnlockDisplay(dpy);
     SyncHandle();
@@ -86,8 +93,8 @@
 			     int count,
 			     int *keysyms_per_keycode)
 {
-    long nbytes;
-    unsigned long nkeysyms;
+    unsigned long nbytes;
+    CARD32 nkeysyms;
     register KeySym *mapping = NULL;
     xGetKeyboardMappingReply rep;
     register xGetKeyboardMappingReq *req;
@@ -102,17 +109,19 @@
 	return (KeySym *) NULL;
     }
 
-    nkeysyms = (unsigned long) rep.length;
+    nkeysyms = rep.length;
     if (nkeysyms > 0) {
-	nbytes = nkeysyms * sizeof (KeySym);
-	mapping = (KeySym *) Xmalloc ((unsigned) nbytes);
-	nbytes = nkeysyms << 2;
+	if (nkeysyms < (INT_MAX / sizeof (KeySym))) {
+	    nbytes = nkeysyms * sizeof (KeySym);
+	    mapping = Xmalloc (nbytes);
+	}
 	if (! mapping) {
-	    _XEatData(dpy, (unsigned long) nbytes);
+	    _XEatDataWords(dpy, rep.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return (KeySym *) NULL;
 	}
+	nbytes = nkeysyms << 2;
 	_XRead32 (dpy, (long *) mapping, nbytes);
     }
     *keysyms_per_keycode = rep.keySymsPerKeyCode;
Index: libx11-1.4.99.1/src/GetProp.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetProp.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetProp.c	2013-05-29 16:18:48.092182372 -0400
@@ -28,6 +28,7 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
 
 int
 XGetWindowProperty(
@@ -48,6 +49,13 @@
     register xGetPropertyReq *req;
     xError error = {0};
 
+    /* Always initialize return values, in case callers fail to initialize
+       them and fail to check the return code for an error. */
+    *actual_type = None;
+    *actual_format = 0;
+    *nitems = *bytesafter = 0L;
+    *prop = (unsigned char *) NULL;
+
     LockDisplay(dpy);
     GetReq (GetProperty, req);
     req->window = w;
@@ -64,10 +72,18 @@
 	return (1);	/* not Success */
 	}
 
-    *prop = (unsigned char *) NULL;
     if (reply.propertyType != None) {
-	long nbytes, netbytes;
-	switch (reply.format) {
+	unsigned long nbytes, netbytes;
+	int format = reply.format;
+
+      /*
+       * Protect against both integer overflow and just plain oversized
+       * memory allocation - no server should ever return this many props.
+       */
+	if (reply.nItems >= (INT_MAX >> 4))
+	    format = -1;	/* fall through to default error case */
+
+	switch (format) {
       /*
        * One extra byte is malloced than is needed to contain the property
        * data, but this last byte is null terminated and convenient for
@@ -76,24 +92,21 @@
        */
 	  case 8:
 	    nbytes = netbytes = reply.nItems;
-	    if (nbytes + 1 > 0 &&
-		(*prop = (unsigned char *) Xmalloc ((unsigned)nbytes + 1)))
+	    if (nbytes + 1 > 0 && (*prop = Xmalloc (nbytes + 1)))
 		_XReadPad (dpy, (char *) *prop, netbytes);
 	    break;
 
 	  case 16:
 	    nbytes = reply.nItems * sizeof (short);
 	    netbytes = reply.nItems << 1;
-	    if (nbytes + 1 > 0 &&
-		(*prop = (unsigned char *) Xmalloc ((unsigned)nbytes + 1)))
+	    if (nbytes + 1 > 0 && (*prop = Xmalloc (nbytes + 1)))
 		_XRead16Pad (dpy, (short *) *prop, netbytes);
 	    break;
 
 	  case 32:
 	    nbytes = reply.nItems * sizeof (long);
 	    netbytes = reply.nItems << 2;
-	    if (nbytes + 1 > 0 &&
-		(*prop = (unsigned char *) Xmalloc ((unsigned)nbytes + 1)))
+	    if (nbytes + 1 > 0 && (*prop = Xmalloc (nbytes + 1)))
 		_XRead32 (dpy, (long *) *prop, netbytes);
 	    break;
 
@@ -115,7 +128,7 @@
 	    break;
 	}
 	if (! *prop) {
-	    _XEatData(dpy, (unsigned long) netbytes);
+	    _XEatDataWords(dpy, reply.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return(BadAlloc);	/* not Success */
Index: libx11-1.4.99.1/src/GetRGBCMap.c
===================================================================
--- libx11-1.4.99.1.orig/src/GetRGBCMap.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/GetRGBCMap.c	2013-05-29 16:18:48.096182372 -0400
@@ -99,8 +99,7 @@
     /*
      * allocate array
      */
-    cmaps = (XStandardColormap *) Xmalloc (ncmaps *
-					   sizeof (XStandardColormap));
+    cmaps = Xmalloc (ncmaps * sizeof (XStandardColormap));
     if (!cmaps) {
 	if (data) Xfree ((char *) data);
 	return False;
Index: libx11-1.4.99.1/src/ImUtil.c
===================================================================
--- libx11-1.4.99.1.orig/src/ImUtil.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/ImUtil.c	2013-05-29 16:18:48.096182372 -0400
@@ -332,7 +332,7 @@
 	    (xpad != 8 && xpad != 16 && xpad != 32) ||
 	    offset < 0)
 	    return (XImage *) NULL;
-	if ((image = (XImage *) Xcalloc(1, (unsigned) sizeof(XImage))) == NULL)
+	if ((image = Xcalloc(1, sizeof(XImage))) == NULL)
 	    return (XImage *) NULL;
 
 	image->width = width;
@@ -850,7 +850,7 @@
 	register unsigned long pixel;
 	char *data;
 
-	if ((subimage = (XImage *) Xcalloc (1, sizeof (XImage))) == NULL)
+	if ((subimage = Xcalloc (1, sizeof (XImage))) == NULL)
 	    return (XImage *) NULL;
 	subimage->width = width;
 	subimage->height = height;
@@ -876,7 +876,7 @@
 	_XInitImageFuncPtrs (subimage);
 	dsize = subimage->bytes_per_line * height;
 	if (subimage->format == XYPixmap) dsize = dsize * subimage->depth;
-	if (((data = Xcalloc (1, (unsigned) dsize)) == NULL) && (dsize > 0)) {
+	if (((data = Xcalloc (1, dsize)) == NULL) && (dsize > 0)) {
 	    Xfree((char *) subimage);
 	    return (XImage *) NULL;
 	}
Index: libx11-1.4.99.1/src/InitExt.c
===================================================================
--- libx11-1.4.99.1.orig/src/InitExt.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/InitExt.c	2013-05-29 16:18:48.096182372 -0400
@@ -49,7 +49,7 @@
 		&codes.first_error)) return (NULL);
 
 	LockDisplay (dpy);
-	if (! (ext = (_XExtension *) Xcalloc (1, sizeof (_XExtension))) ||
+	if (! (ext = Xcalloc (1, sizeof (_XExtension))) ||
 	    ! (ext->name = strdup(name))) {
 	    if (ext) Xfree((char *) ext);
 	    UnlockDisplay(dpy);
@@ -71,7 +71,7 @@
     register _XExtension *ext;
 
     LockDisplay (dpy);
-    if (! (ext = (_XExtension *) Xcalloc (1, sizeof (_XExtension)))) {
+    if (! (ext = Xcalloc (1, sizeof (_XExtension)))) {
 	UnlockDisplay(dpy);
 	return (XExtCodes *) NULL;
     }
Index: libx11-1.4.99.1/src/IntAtom.c
===================================================================
--- libx11-1.4.99.1.orig/src/IntAtom.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/IntAtom.c	2013-05-29 16:18:48.096182372 -0400
@@ -72,7 +72,7 @@
 
     /* look in the cache first */
     if (!(atoms = dpy->atoms)) {
-	dpy->atoms = atoms = (AtomTable *)Xcalloc(1, sizeof(AtomTable));
+	dpy->atoms = atoms = Xcalloc(1, sizeof(AtomTable));
 	dpy->free_funcs->atoms = _XFreeAtomTable;
     }
     sig = 0;
@@ -127,7 +127,7 @@
 
     if (!dpy->atoms) {
 	if (idx < 0) {
-	    dpy->atoms = (AtomTable *)Xcalloc(1, sizeof(AtomTable));
+	    dpy->atoms = Xcalloc(1, sizeof(AtomTable));
 	    dpy->free_funcs->atoms = _XFreeAtomTable;
 	}
 	if (!dpy->atoms)
@@ -147,7 +147,7 @@
 	    }
 	}
     }
-    e = (Entry)Xmalloc(sizeof(EntryRec) + n + 1);
+    e = Xmalloc(sizeof(EntryRec) + n + 1);
     if (e) {
 	e->sig = sig;
 	e->atom = atom;
Index: libx11-1.4.99.1/src/KeyBind.c
===================================================================
--- libx11-1.4.99.1.orig/src/KeyBind.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/KeyBind.c	2013-05-29 16:18:48.096182372 -0400
@@ -997,11 +997,9 @@
     tmp = dpy->key_bindings;
     nb = sizeof(KeySym) * nm;
 
-    if ((! (p = (struct _XKeytrans *) Xcalloc( 1, sizeof(struct _XKeytrans)))) ||
-	((! (p->string = (char *) Xmalloc( (unsigned) nbytes))) &&
-	 (nbytes > 0)) ||
-	((! (p->modifiers = (KeySym *) Xmalloc( (unsigned) nb))) &&
-	 (nb > 0))) {
+    if ((! (p = Xcalloc( 1, sizeof(struct _XKeytrans)))) ||
+	((! (p->string = Xmalloc(nbytes))) && (nbytes > 0)) ||
+	((! (p->modifiers = Xmalloc(nb))) && (nb > 0))) {
 	if (p) {
 	    if (p->string) Xfree(p->string);
 	    if (p->modifiers) Xfree((char *) p->modifiers);
Index: libx11-1.4.99.1/src/LiHosts.c
===================================================================
--- libx11-1.4.99.1.orig/src/LiHosts.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/LiHosts.c	2013-05-29 16:18:48.096182372 -0400
@@ -62,6 +62,8 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
+
 /*
  * can be freed using XFree.
  */
@@ -73,7 +75,6 @@
 {
     register XHostAddress *outbuf = NULL, *op;
     xListHostsReply reply;
-    long nbytes;
     unsigned char *buf, *bp;
     register unsigned i;
     register xListHostsReq *req;
@@ -90,19 +91,26 @@
     }
 
     if (reply.nHosts) {
-	nbytes = reply.length << 2;	/* compute number of bytes in reply */
-
-	op = outbuf = (XHostAddress *)
-	    Xmalloc((unsigned) (nbytes +
-	      (reply.nHosts * sizeof(XHostAddress)) +
-	      (reply.nHosts * sizeof(XServerInterpretedAddress))));
+	unsigned long nbytes = reply.length << 2; /* number of bytes in reply */
+	const unsigned long max_hosts = INT_MAX /
+	    (sizeof(XHostAddress) + sizeof(XServerInterpretedAddress));
+
+	if (reply.nHosts < max_hosts) {
+	    unsigned long hostbytes = reply.nHosts *
+		(sizeof(XHostAddress) + sizeof(XServerInterpretedAddress));
+
+	    if (reply.length < (INT_MAX >> 2) &&
+		(hostbytes >> 2) < ((INT_MAX >> 2) - reply.length))
+		outbuf = Xmalloc(nbytes + hostbytes);
+	}
 
 	if (! outbuf) {
-	    _XEatData(dpy, (unsigned long) nbytes);
+	    _XEatDataWords(dpy, reply.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return (XHostAddress *) NULL;
 	}
+	op = outbuf;
 	sip = (XServerInterpretedAddress *)
 	 (((unsigned char  *) outbuf) + (reply.nHosts * sizeof(XHostAddress)));
 	bp = buf = ((unsigned char  *) sip)
Index: libx11-1.4.99.1/src/LiICmaps.c
===================================================================
--- libx11-1.4.99.1.orig/src/LiICmaps.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/LiICmaps.c	2013-05-29 16:18:48.096182372 -0400
@@ -34,7 +34,7 @@
     Window win,
     int *n)  /* RETURN */
 {
-    long nbytes;
+    unsigned long nbytes;
     Colormap *cmaps;
     xListInstalledColormapsReply rep;
     register xResourceReq *req;
@@ -51,14 +51,14 @@
 
     if (rep.nColormaps) {
 	nbytes = rep.nColormaps * sizeof(Colormap);
-	cmaps = (Colormap *) Xmalloc((unsigned) nbytes);
-	nbytes = rep.nColormaps << 2;
+	cmaps = Xmalloc(nbytes);
 	if (! cmaps) {
-	    _XEatData(dpy, (unsigned long) nbytes);
+	    _XEatDataWords(dpy, rep.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return((Colormap *) NULL);
 	}
+	nbytes = rep.nColormaps << 2;
 	_XRead32 (dpy, (long *) cmaps, nbytes);
     }
     else cmaps = (Colormap *) NULL;
Index: libx11-1.4.99.1/src/LiProps.c
===================================================================
--- libx11-1.4.99.1.orig/src/LiProps.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/LiProps.c	2013-05-29 16:18:48.096182372 -0400
@@ -34,7 +34,7 @@
     Window window,
     int *n_props)  /* RETURN */
 {
-    long nbytes;
+    unsigned long nbytes;
     xListPropertiesReply rep;
     Atom *properties;
     register xResourceReq *req;
@@ -50,14 +50,14 @@
 
     if (rep.nProperties) {
 	nbytes = rep.nProperties * sizeof(Atom);
-	properties = (Atom *) Xmalloc ((unsigned) nbytes);
-	nbytes = rep.nProperties << 2;
+	properties = Xmalloc (nbytes);
 	if (! properties) {
-	    _XEatData(dpy, (unsigned long) nbytes);
+	    _XEatDataWords(dpy, rep.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return (Atom *) NULL;
 	}
+	nbytes = rep.nProperties << 2;
 	_XRead32 (dpy, (long *) properties, nbytes);
     }
     else properties = (Atom *) NULL;
Index: libx11-1.4.99.1/src/Makefile.am
===================================================================
--- libx11-1.4.99.1.orig/src/Makefile.am	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Makefile.am	2013-05-29 16:18:48.096182372 -0400
@@ -210,6 +210,7 @@
                   ParseCmd.c \
                   ParseCol.c \
                   ParseGeom.c \
+                  pathmax.h \
                   PeekEvent.c \
                   PeekIfEv.c \
                   Pending.c \
Index: libx11-1.4.99.1/src/ModMap.c
===================================================================
--- libx11-1.4.99.1.orig/src/ModMap.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/ModMap.c	2013-05-29 16:18:48.096182372 -0400
@@ -28,6 +28,7 @@
 #include <config.h>
 #endif
 #include "Xlibint.h"
+#include <limits.h>
 
 XModifierKeymap *
 XGetModifierMapping(register Display *dpy)
@@ -41,13 +42,17 @@
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
 
-    nbytes = (unsigned long)rep.length << 2;
-    res = (XModifierKeymap *) Xmalloc(sizeof (XModifierKeymap));
-    if (res) res->modifiermap = (KeyCode *) Xmalloc ((unsigned) nbytes);
+    if (rep.length < (LONG_MAX >> 2)) {
+	nbytes = (unsigned long)rep.length << 2;
+	res = Xmalloc(sizeof (XModifierKeymap));
+	if (res)
+	    res->modifiermap = Xmalloc (nbytes);
+    } else
+	res = NULL;
     if ((! res) || (! res->modifiermap)) {
 	if (res) Xfree((char *) res);
 	res = (XModifierKeymap *) NULL;
-	_XEatData(dpy, nbytes);
+	_XEatDataWords(dpy, rep.length);
     } else {
 	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
 	res->max_keypermod = rep.numKeyPerModifier;
@@ -92,11 +97,11 @@
 XModifierKeymap *
 XNewModifiermap(int keyspermodifier)
 {
-    XModifierKeymap *res = (XModifierKeymap *) Xmalloc((sizeof (XModifierKeymap)));
+    XModifierKeymap *res = Xmalloc((sizeof (XModifierKeymap)));
     if (res) {
 	res->max_keypermod = keyspermodifier;
 	res->modifiermap = (keyspermodifier > 0 ?
-			    (KeyCode *) Xmalloc((unsigned) (8 * keyspermodifier))
+			    Xmalloc(8 * keyspermodifier)
 			    : (KeyCode *) NULL);
 	if (keyspermodifier && (res->modifiermap == NULL)) {
 	    Xfree((char *) res);
Index: libx11-1.4.99.1/src/OpenDis.c
===================================================================
--- libx11-1.4.99.1.orig/src/OpenDis.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/OpenDis.c	2013-05-29 16:18:48.096182372 -0400
@@ -112,7 +112,7 @@
 /*
  * Attempt to allocate a display structure. Return NULL if allocation fails.
  */
-	if ((dpy = (Display *)Xcalloc(1, sizeof(Display))) == NULL) {
+	if ((dpy = Xcalloc(1, sizeof(Display))) == NULL) {
 		return(NULL);
 	}
 
@@ -265,9 +265,7 @@
 	dpy->qlen = 0;
 
 	/* Set up free-function record */
-	if ((dpy->free_funcs = (_XFreeFuncRec *)Xcalloc(1,
-							sizeof(_XFreeFuncRec)))
-	    == NULL) {
+	if ((dpy->free_funcs = Xcalloc(1, sizeof(_XFreeFuncRec))) == NULL) {
 	    OutOfMemory (dpy);
 	    return(NULL);
 	}
@@ -335,7 +333,7 @@
 	    return (NULL);
 	}
 
-	dpy->vendor = (char *) Xmalloc((unsigned) (u.setup->nbytesVendor + 1));
+	dpy->vendor = Xmalloc(u.setup->nbytesVendor + 1);
 	if (dpy->vendor == NULL) {
 	    OutOfMemory(dpy);
 	    return (NULL);
@@ -361,9 +359,7 @@
 /*
  * Now iterate down setup information.....
  */
-	dpy->pixmap_format =
-	    (ScreenFormat *)Xmalloc(
-		(unsigned) (dpy->nformats *sizeof(ScreenFormat)));
+	dpy->pixmap_format = Xcalloc(dpy->nformats, sizeof(ScreenFormat));
 	if (dpy->pixmap_format == NULL) {
 	        OutOfMemory (dpy);
 		return(NULL);
@@ -391,8 +387,7 @@
 /*
  * next the Screen structures.
  */
-	dpy->screens =
-	    (Screen *)Xmalloc((unsigned) dpy->nscreens*sizeof(Screen));
+	dpy->screens = Xcalloc(dpy->nscreens, sizeof(Screen));
 	if (dpy->screens == NULL) {
 	        OutOfMemory (dpy);
 		return(NULL);
@@ -434,8 +429,7 @@
 /*
  * lets set up the depth structures.
  */
-	    sp->depths = (Depth *)Xmalloc(
-			(unsigned)sp->ndepths*sizeof(Depth));
+	    sp->depths = Xcalloc(sp->ndepths, sizeof(Depth));
 	    if (sp->depths == NULL) {
 		OutOfMemory (dpy);
 		return(NULL);
@@ -457,8 +451,7 @@
 		dp->nvisuals = u.dp->nVisuals;
 		u.dp = (xDepth *) (((char *) u.dp) + sz_xDepth);
 		if (dp->nvisuals > 0) {
-		    dp->visuals =
-		      (Visual *)Xmalloc((unsigned)dp->nvisuals*sizeof(Visual));
+		    dp->visuals = Xcalloc(dp->nvisuals, sizeof(Visual));
 		    if (dp->visuals == NULL) {
 			OutOfMemory (dpy);
 			return(NULL);
@@ -569,7 +562,7 @@
 		    dpy->xdefaults[reply.nItems] = '\0';
 		}
 		else if (reply.propertyType != None)
-		    _XEatData(dpy, reply.nItems * (reply.format >> 3));
+		    _XEatDataWords(dpy, reply.length);
 	    }
 	}
 	UnlockDisplay(dpy);
Index: libx11-1.4.99.1/src/PixFormats.c
===================================================================
--- libx11-1.4.99.1.orig/src/PixFormats.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/PixFormats.c	2013-05-29 16:18:48.096182372 -0400
@@ -38,8 +38,8 @@
     Display *dpy,
     int *count)	/* RETURN */
 {
-    XPixmapFormatValues *formats = (XPixmapFormatValues *)
-	Xmalloc((unsigned) (dpy->nformats * sizeof (XPixmapFormatValues)));
+    XPixmapFormatValues *formats =
+	Xmalloc(dpy->nformats * sizeof (XPixmapFormatValues));
 
     if (formats) {
 	register int i;
Index: libx11-1.4.99.1/src/PolyReg.c
===================================================================
--- libx11-1.4.99.1.orig/src/PolyReg.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/PolyReg.c	2013-05-29 16:18:48.096182372 -0400
@@ -95,8 +95,7 @@
     {
         if (*iSLLBlock > SLLSPERBLOCK-1)
         {
-            tmpSLLBlock =
-		  (ScanLineListBlock *)Xmalloc(sizeof(ScanLineListBlock));
+            tmpSLLBlock = Xmalloc(sizeof(ScanLineListBlock));
             (*SLLBlock)->next = tmpSLLBlock;
             tmpSLLBlock->next = (ScanLineListBlock *)NULL;
             *SLLBlock = tmpSLLBlock;
@@ -410,8 +409,7 @@
 
     numRects = ((numFullPtBlocks * NUMPTSTOBUFFER) + iCurPtBlock) >> 1;
 
-    if (!(reg->rects = (BOX *)Xrealloc((char *)reg->rects,
-	    (unsigned) (sizeof(BOX) * numRects))))  {
+    if (!(reg->rects = Xrealloc(reg->rects, sizeof(BOX) * numRects))) {
 	Xfree(prevRects);
 	return(0);
     }
@@ -521,8 +519,7 @@
 
     if (Count < 2) return region;
 
-    if (! (pETEs = (EdgeTableEntry *)
-	   Xmalloc((unsigned) (sizeof(EdgeTableEntry) * Count)))) {
+    if (! (pETEs = Xmalloc(sizeof(EdgeTableEntry) * Count))) {
 	XDestroyRegion(region);
 	return (Region) NULL;
     }
@@ -559,7 +556,7 @@
                  *  send out the buffer
                  */
                 if (iPts == NUMPTSTOBUFFER) {
-                    tmpPtBlock = (POINTBLOCK *)Xmalloc(sizeof(POINTBLOCK));
+                    tmpPtBlock = Xmalloc(sizeof(POINTBLOCK));
                     curPtBlock->next = tmpPtBlock;
                     curPtBlock = tmpPtBlock;
                     pts = curPtBlock->pts;
@@ -605,7 +602,7 @@
                      *  send out the buffer
                      */
                     if (iPts == NUMPTSTOBUFFER) {
-                        tmpPtBlock = (POINTBLOCK *)Xmalloc(sizeof(POINTBLOCK));
+                        tmpPtBlock = Xmalloc(sizeof(POINTBLOCK));
                         curPtBlock->next = tmpPtBlock;
                         curPtBlock = tmpPtBlock;
                         pts = curPtBlock->pts;
Index: libx11-1.4.99.1/src/PropAlloc.c
===================================================================
--- libx11-1.4.99.1.orig/src/PropAlloc.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/PropAlloc.c	2013-05-29 16:18:48.096182372 -0400
@@ -39,20 +39,19 @@
 
 XSizeHints *XAllocSizeHints (void)
 {
-    return ((XSizeHints *) Xcalloc (1, (unsigned) sizeof (XSizeHints)));
+    return Xcalloc (1, sizeof (XSizeHints));
 }
 
 
 XStandardColormap *XAllocStandardColormap (void)
 {
-    return ((XStandardColormap *)
-	    Xcalloc (1, (unsigned) sizeof (XStandardColormap)));
+    return Xcalloc (1, sizeof (XStandardColormap));
 }
 
 
 XWMHints *XAllocWMHints (void)
 {
-    return ((XWMHints *) Xcalloc (1, (unsigned) sizeof (XWMHints)));
+    return Xcalloc (1, sizeof (XWMHints));
 }
 
 
@@ -69,7 +68,7 @@
 
 XIconSize *XAllocIconSize (void)
 {
-    return ((XIconSize *) Xcalloc (1, (unsigned) sizeof (XIconSize)));
+    return Xcalloc (1, sizeof (XIconSize));
 }
 
 
Index: libx11-1.4.99.1/src/PutBEvent.c
===================================================================
--- libx11-1.4.99.1.orig/src/PutBEvent.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/PutBEvent.c	2013-05-29 16:18:48.100182372 -0400
@@ -41,7 +41,7 @@
 	XEvent store = *event;
 
 	if (!dpy->qfree) {
-    	    if ((dpy->qfree = (_XQEvent *) Xmalloc (sizeof (_XQEvent))) == NULL) {
+	    if ((dpy->qfree = Xmalloc (sizeof (_XQEvent))) == NULL) {
 		return 0;
 	    }
 	    dpy->qfree->next = NULL;
Index: libx11-1.4.99.1/src/PutImage.c
===================================================================
--- libx11-1.4.99.1.orig/src/PutImage.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/PutImage.c	2013-05-29 16:18:48.100182372 -0400
@@ -680,7 +680,7 @@
 
     length = ROUNDUP(length, 4);
     if ((dpy->bufptr + length) > dpy->bufmax) {
-	if ((buf = _XAllocScratch(dpy, (unsigned long) (length))) == NULL) {
+	if ((buf = _XAllocScratch(dpy, length)) == NULL) {
 	    UnGetReq(PutImage);
 	    return;
 	}
@@ -703,13 +703,13 @@
 	bytes_per_temp_plane = bytes_per_line * req->height;
 	temp_length = ROUNDUP(bytes_per_temp_plane * image->depth, 4);
 	if (buf == dpy->bufptr) {
-	    if (! (temp = _XAllocScratch(dpy, (unsigned long) temp_length))) {
+	    if (! (temp = _XAllocScratch(dpy, temp_length))) {
 		UnGetReq(PutImage);
 		return;
 	    }
 	}
 	else
-	    if ((extra = temp = Xmalloc((unsigned) temp_length)) == NULL) {
+	    if ((extra = temp = Xmalloc(temp_length)) == NULL) {
 		UnGetReq(PutImage);
 		return;
 	    }
@@ -778,8 +778,7 @@
 	  (req_yoffset * image->bytes_per_line) +
 	  ((req_xoffset * image->bits_per_pixel) >> 3);
     if ((image->bits_per_pixel == 4) && ((unsigned int) req_xoffset & 0x01)) {
-	if (! (shifted_src = (unsigned char *)
-	       Xmalloc((unsigned) (req->height * image->bytes_per_line)))) {
+	if (! (shifted_src = Xmalloc(req->height * image->bytes_per_line))) {
 	    UnGetReq(PutImage);
 	    return;
 	}
@@ -810,7 +809,7 @@
 	dest = (unsigned char *)dpy->bufptr;
     else
 	if ((dest = (unsigned char *)
-	     _XAllocScratch(dpy, (unsigned long)(length))) == NULL) {
+	     _XAllocScratch(dpy, length)) == NULL) {
 	    if (shifted_src) Xfree((char *) shifted_src);
 	    UnGetReq(PutImage);
 	    return;
@@ -1001,7 +1000,7 @@
 	    img.bits_per_pixel = dest_bits_per_pixel;
 	    img.bytes_per_line = ROUNDUP((dest_bits_per_pixel * width),
 					 dest_scanline_pad) >> 3;
-	    img.data = Xmalloc((unsigned) (img.bytes_per_line * height));
+	    img.data = Xmalloc(img.bytes_per_line * height);
 	    if (img.data == NULL)
 		return 0;
 	    _XInitImageFuncPtrs(&img);
Index: libx11-1.4.99.1/src/QuColors.c
===================================================================
--- libx11-1.4.99.1.orig/src/QuColors.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/QuColors.c	2013-05-29 16:18:48.100182372 -0400
@@ -37,9 +37,7 @@
     int ncolors)
 {
     register int i;
-    xrgb *color;
     xQueryColorsReply rep;
-    long nbytes;
     register xQueryColorsReq *req;
 
     LockDisplay(dpy);
@@ -53,8 +51,9 @@
        /* XXX this isn't very efficient */
 
     if (_XReply(dpy, (xReply *) &rep, 0, xFalse) != 0) {
-	if ((color = (xrgb *)
-	    Xmalloc((unsigned) (nbytes = (long) ncolors * SIZEOF(xrgb))))) {
+	unsigned long nbytes = (long) ncolors * SIZEOF(xrgb);
+	xrgb *color = Xmalloc(nbytes);
+	if (color != NULL) {
 
 	    _XRead(dpy, (char *) color, nbytes);
 
@@ -68,7 +67,8 @@
 	    }
 	    Xfree((char *)color);
 	}
-	else _XEatData(dpy, (unsigned long) nbytes);
+	else
+	    _XEatDataWords(dpy, rep.length);
     }
     UnlockDisplay(dpy);
     SyncHandle();
Index: libx11-1.4.99.1/src/QuTree.c
===================================================================
--- libx11-1.4.99.1.orig/src/QuTree.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/QuTree.c	2013-05-29 16:18:48.100182372 -0400
@@ -37,7 +37,7 @@
     Window **children,	/* RETURN */
     unsigned int *nchildren)  /* RETURN */
 {
-    long nbytes;
+    unsigned long nbytes;
     xQueryTreeReply rep;
     register xResourceReq *req;
 
@@ -52,14 +52,14 @@
     *children = (Window *) NULL;
     if (rep.nChildren != 0) {
 	nbytes = rep.nChildren * sizeof(Window);
-	*children = (Window *) Xmalloc((unsigned) nbytes);
-	nbytes = rep.nChildren << 2;
+	*children = Xmalloc(nbytes);
 	if (! *children) {
-	    _XEatData(dpy, (unsigned long) nbytes);
+	    _XEatDataWords(dpy, rep.length);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
 	    return (0);
 	}
+	nbytes = rep.nChildren << 2;
 	_XRead32 (dpy, (long *) *children, nbytes);
     }
     *parent = rep.parent;
Index: libx11-1.4.99.1/src/Quarks.c
===================================================================
--- libx11-1.4.99.1.orig/src/Quarks.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Quarks.c	2013-05-29 16:18:48.100182372 -0400
@@ -190,15 +190,14 @@
 	newmask = (oldmask << 1) + 1;
     else {
 	if (!stringTable) {
-	    stringTable = (XrmString **)Xmalloc(sizeof(XrmString *) *
-						CHUNKPER);
+	    stringTable = Xmalloc(sizeof(XrmString *) * CHUNKPER);
 	    if (!stringTable)
 		return False;
 	    stringTable[0] = (XrmString *)NULL;
 	}
 #ifdef PERMQ
 	if (!permTable)
-	    permTable = (Bits **)Xmalloc(sizeof(Bits *) * CHUNKPER);
+	    permTable = Xmalloc(sizeof(Bits *) * CHUNKPER);
 	if (!permTable)
 	    return False;
 #endif
@@ -293,13 +292,13 @@
     q = nextQuark;
     if (!(q & QUANTUMMASK)) {
 	if (!(q & CHUNKMASK)) {
-	    if (!(new = Xrealloc((char *)stringTable,
+	    if (!(new = Xrealloc(stringTable,
 				 sizeof(XrmString *) *
 				 ((q >> QUANTUMSHIFT) + CHUNKPER))))
 		goto fail;
 	    stringTable = (XrmString **)new;
 #ifdef PERMQ
-	    if (!(new = Xrealloc((char *)permTable,
+	    if (!(new = Xrealloc(permTable,
 				 sizeof(Bits *) *
 				 ((q >> QUANTUMSHIFT) + CHUNKPER))))
 		goto fail;
Index: libx11-1.4.99.1/src/RdBitF.c
===================================================================
--- libx11-1.4.99.1.orig/src/RdBitF.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/RdBitF.c	2013-05-29 16:18:48.100182372 -0400
@@ -191,7 +191,7 @@
 	bytes_per_line = (ww+7)/8 + padding;
 
 	size = bytes_per_line * hh;
-	bits = (unsigned char *) Xmalloc ((unsigned int) size);
+	bits = Xmalloc (size);
 	if (!bits)
 	  RETURN (BitmapNoMemory);
 
Index: libx11-1.4.99.1/src/Region.c
===================================================================
--- libx11-1.4.99.1.orig/src/Region.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Region.c	2013-05-29 16:18:48.100182372 -0400
@@ -139,9 +139,9 @@
 {
     Region temp;
 
-    if (! (temp = ( Region )Xmalloc( (unsigned) sizeof( REGION ))))
+    if (! (temp = Xmalloc(sizeof( REGION ))))
 	return (Region) NULL;
-    if (! (temp->rects = ( BOX * )Xmalloc( (unsigned) sizeof( BOX )))) {
+    if (! (temp->rects = Xmalloc(sizeof( BOX )))) {
 	Xfree((char *) temp);
 	return (Region) NULL;
     }
@@ -521,9 +521,9 @@
             {
 		BOX *prevRects = dstrgn->rects;
 
-                if (! (dstrgn->rects = (BOX *)
-		       Xrealloc((char *) dstrgn->rects,
-				(unsigned) rgn->numRects * (sizeof(BOX))))) {
+		dstrgn->rects = Xrealloc(dstrgn->rects,
+					 rgn->numRects * (sizeof(BOX)));
+		if (! dstrgn->rects) {
 		    Xfree(prevRects);
 		    return;
 		}
@@ -788,8 +788,7 @@
      */
     newReg->size = max(reg1->numRects,reg2->numRects) * 2;
 
-    if (! (newReg->rects = (BoxPtr)
-	   Xmalloc ((unsigned) (sizeof(BoxRec) * newReg->size)))) {
+    if (! (newReg->rects = Xmalloc (sizeof(BoxRec) * newReg->size))) {
 	newReg->size = 0;
 	return;
     }
@@ -980,8 +979,8 @@
 	{
 	    BoxPtr prev_rects = newReg->rects;
 	    newReg->size = newReg->numRects;
-	    newReg->rects = (BoxPtr) Xrealloc ((char *) newReg->rects,
-				   (unsigned) (sizeof(BoxRec) * newReg->size));
+	    newReg->rects = Xrealloc (newReg->rects,
+				      sizeof(BoxRec) * newReg->size);
 	    if (! newReg->rects)
 		newReg->rects = prev_rects;
 	}
@@ -993,7 +992,7 @@
 	     */
 	    newReg->size = 1;
 	    Xfree((char *) newReg->rects);
-	    newReg->rects = (BoxPtr) Xmalloc(sizeof(BoxRec));
+	    newReg->rects = Xmalloc(sizeof(BoxRec));
 	}
     }
     Xfree ((char *) oldRects);
Index: libx11-1.4.99.1/src/RegstFlt.c
===================================================================
--- libx11-1.4.99.1.orig/src/RegstFlt.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/RegstFlt.c	2013-05-29 16:18:48.100182372 -0400
@@ -85,7 +85,7 @@
 {
     XFilterEventRec		*rec;
 
-    rec = (XFilterEventList)Xmalloc(sizeof(XFilterEventRec));
+    rec = Xmalloc(sizeof(XFilterEventRec));
     if (!rec)
 	return;
     rec->window = window;
@@ -117,7 +117,7 @@
 {
     XFilterEventRec		*rec;
 
-    rec = (XFilterEventList)Xmalloc(sizeof(XFilterEventRec));
+    rec = Xmalloc(sizeof(XFilterEventRec));
     if (!rec)
 	return;
     rec->window = window;
Index: libx11-1.4.99.1/src/SetFPath.c
===================================================================
--- libx11-1.4.99.1.orig/src/SetFPath.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/SetFPath.c	2013-05-29 16:18:48.100182372 -0400
@@ -52,7 +52,7 @@
 	}
 	nbytes = (n + 3) & ~3;
 	req->length += nbytes >> 2;
-	if ((p = (char *) Xmalloc ((unsigned) nbytes))) {
+	if ((p = Xmalloc (nbytes))) {
 		/*
 	 	 * pack into counted strings.
 	 	 */
Index: libx11-1.4.99.1/src/SetHints.c
===================================================================
--- libx11-1.4.99.1.orig/src/SetHints.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/SetHints.c	2013-05-29 16:18:48.100182372 -0400
@@ -184,7 +184,7 @@
 #define size_of_the_real_thing sizeof	/* avoid grepping screwups */
 	unsigned nbytes = count * size_of_the_real_thing(xPropIconSize);
 #undef size_of_the_real_thing
-	if ((prop = pp = (xPropIconSize *) Xmalloc (nbytes))) {
+	if ((prop = pp = Xmalloc (nbytes))) {
 	    for (i = 0; i < count; i++) {
 		pp->minWidth  = list->min_width;
 		pp->minHeight = list->min_height;
@@ -216,7 +216,7 @@
 	for (i = 0, nbytes = 0; i < argc; i++) {
 		nbytes += safestrlen(argv[i]) + 1;
 	}
-	if ((bp = buf = Xmalloc((unsigned) nbytes))) {
+	if ((bp = buf = Xmalloc(nbytes))) {
 	    /* copy arguments into single buffer */
 	    for (i = 0; i < argc; i++) {
 		if (argv[i]) {
@@ -297,7 +297,7 @@
 
 	len_nm = safestrlen(classhint->res_name);
 	len_cl = safestrlen(classhint->res_class);
-	if ((class_string = s = Xmalloc((unsigned) (len_nm + len_cl + 2)))) {
+	if ((class_string = s = Xmalloc(len_nm + len_cl + 2))) {
 	    if (len_nm) {
 		strcpy(s, classhint->res_name);
 		s += len_nm + 1;
Index: libx11-1.4.99.1/src/StrToText.c
===================================================================
--- libx11-1.4.99.1.orig/src/StrToText.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/StrToText.c	2013-05-29 16:18:48.100182372 -0400
@@ -78,7 +78,7 @@
 	    }
 	}
     } else {
-	proto.value = (unsigned char *) Xmalloc (1);	/* easier for client */
+	proto.value = Xmalloc (1);		/* easier for client */
 	if (!proto.value) return False;
 
 	proto.value[0] = '\0';
Index: libx11-1.4.99.1/src/TextToStr.c
===================================================================
--- libx11-1.4.99.1.orig/src/TextToStr.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/TextToStr.c	2013-05-29 16:18:48.100182372 -0400
@@ -72,10 +72,10 @@
     /*
      * allocate list and duplicate
      */
-    list = (char **) Xmalloc (nelements * sizeof (char *));
+    list = Xmalloc (nelements * sizeof (char *));
     if (!list) return False;
 
-    start = (char *) Xmalloc ((datalen + 1) * sizeof (char));	/* for <NUL> */
+    start = Xmalloc ((datalen + 1) * sizeof (char));	/* for <NUL> */
     if (!start) {
 	Xfree ((char *) list);
 	return False;
Index: libx11-1.4.99.1/src/VisUtil.c
===================================================================
--- libx11-1.4.99.1.orig/src/VisUtil.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/VisUtil.c	2013-05-29 16:18:48.100182372 -0400
@@ -75,8 +75,7 @@
 
   count = 0;
   total = 10;
-  if (! (vip_base = vip = (XVisualInfo *)
-	 Xmalloc((unsigned) (sizeof(XVisualInfo) * total)))) {
+  if (! (vip_base = vip = Xmalloc(sizeof(XVisualInfo) * total))) {
       UnlockDisplay(dpy);
       return (XVisualInfo *) NULL;
   }
@@ -132,9 +131,8 @@
                 {
 		  XVisualInfo *old_vip_base = vip_base;
                   total += 10;
-                  if (! (vip_base = (XVisualInfo *)
-			 Xrealloc((char *) vip_base,
-				  (unsigned) (sizeof(XVisualInfo) * total)))) {
+                  if (! (vip_base = Xrealloc(vip_base,
+					     sizeof(XVisualInfo) * total))) {
 		      Xfree((char *) old_vip_base);
 		      UnlockDisplay(dpy);
 		      return (XVisualInfo *) NULL;
Index: libx11-1.4.99.1/src/WrBitF.c
===================================================================
--- libx11-1.4.99.1.orig/src/WrBitF.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/WrBitF.c	2013-05-29 16:18:48.100182372 -0400
@@ -53,7 +53,7 @@
   bytes_per_line = (width+7)/8;
   *resultsize = bytes_per_line * height;           /* Calculate size of data */
 
-  data = (char *) Xmalloc( *resultsize );           /* Get space for data */
+  data = Xmalloc( *resultsize );                   /* Get space for data */
   if (!data)
     return(ERR_RETURN);
 
Index: libx11-1.4.99.1/src/XlibInt.c
===================================================================
--- libx11-1.4.99.1.orig/src/XlibInt.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/XlibInt.c	2013-05-29 16:18:48.104182372 -0400
@@ -152,7 +152,7 @@
 #ifdef USE_POLL
     struct pollfd *pfp;
 
-    pfp = (struct pollfd *)Xmalloc(POLLFD_CACHE_SIZE * sizeof(struct pollfd));
+    pfp = Xmalloc(POLLFD_CACHE_SIZE * sizeof(struct pollfd));
     if (!pfp)
 	return False;
     pfp[0].fd = dpy->fd;
@@ -492,10 +492,10 @@
     struct _XConnWatchInfo *watchers;
     XPointer *wd;
 
-    new_conni = (struct _XConnectionInfo*)Xmalloc(sizeof(struct _XConnectionInfo));
+    new_conni = Xmalloc(sizeof(struct _XConnectionInfo));
     if (!new_conni)
 	return 0;
-    new_conni->watch_data = (XPointer *)Xmalloc(dpy->watcher_count * sizeof(XPointer));
+    new_conni->watch_data = Xmalloc(dpy->watcher_count * sizeof(XPointer));
     if (!new_conni->watch_data) {
 	Xfree(new_conni);
 	return 0;
@@ -582,7 +582,7 @@
     count = 0;
     for (info_list=dpy->im_fd_info; info_list; info_list=info_list->next)
 	count++;
-    fd_list = (int*) Xmalloc (count * sizeof(int));
+    fd_list = Xmalloc (count * sizeof(int));
     if (!fd_list) {
 	UnlockDisplay(dpy);
 	return 0;
@@ -655,9 +655,8 @@
 
     /* allocate new watch data */
     for (info_list=dpy->im_fd_info; info_list; info_list=info_list->next) {
-	wd_array = (XPointer *)Xrealloc((char *)info_list->watch_data,
-					(dpy->watcher_count + 1) *
-					sizeof(XPointer));
+	wd_array = Xrealloc(info_list->watch_data,
+			    (dpy->watcher_count + 1) * sizeof(XPointer));
 	if (!wd_array) {
 	    UnlockDisplay(dpy);
 	    return 0;
@@ -666,7 +665,7 @@
 	wd_array[dpy->watcher_count] = NULL;	/* for cleanliness */
     }
 
-    new_watcher = (struct _XConnWatchInfo*)Xmalloc(sizeof(struct _XConnWatchInfo));
+    new_watcher = Xmalloc(sizeof(struct _XConnWatchInfo));
     if (!new_watcher) {
 	UnlockDisplay(dpy);
 	return 0;
@@ -874,8 +873,7 @@
 		/* If dpy->qfree is non-NULL do this, else malloc a new one. */
 		dpy->qfree = qelt->next;
 	}
-	else if ((qelt =
-	    (_XQEvent *) Xmalloc((unsigned)sizeof(_XQEvent))) == NULL) {
+	else if ((qelt = Xmalloc(sizeof(_XQEvent))) == NULL) {
 		/* Malloc call failed! */
 		ESET(ENOMEM);
 		_XIOError(dpy);
@@ -1636,7 +1634,7 @@
 {
 	if (nbytes > dpy->scratch_length) {
 	    if (dpy->scratch_buffer) Xfree (dpy->scratch_buffer);
-	    if ((dpy->scratch_buffer = Xmalloc((unsigned) nbytes)))
+	    if ((dpy->scratch_buffer = Xmalloc(nbytes)))
 		dpy->scratch_length = nbytes;
 	    else dpy->scratch_length = 0;
 	}
Index: libx11-1.4.99.1/src/Xrm.c
===================================================================
--- libx11-1.4.99.1.orig/src/Xrm.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/Xrm.c	2013-05-29 16:18:48.104182372 -0400
@@ -62,6 +62,7 @@
 #endif
 #include	<X11/Xos.h>
 #include	<sys/stat.h>
+#include	<limits.h>
 #include "Xresinternal.h"
 #include "Xresource.h"
 
@@ -494,7 +495,7 @@
 {
     register XrmDatabase db;
 
-    db = (XrmDatabase) Xmalloc(sizeof(XrmHashBucketRec));
+    db = Xmalloc(sizeof(XrmHashBucketRec));
     if (db) {
 	_XCreateMutex(&db->linfo);
 	db->table = (NTable)NULL;
@@ -827,7 +828,7 @@
     NTable *nprev, *firstpprev;
 
 #define NEWTABLE(q,i) \
-    table = (NTable)Xmalloc(sizeof(LTableRec)); \
+    table = Xmalloc(sizeof(LTableRec)); \
     if (!table) \
 	return; \
     table->name = q; \
@@ -840,7 +841,7 @@
 	nprev = NodeBuckets(table); \
     } else { \
 	table->leaf = 1; \
-	if (!(nprev = (NTable *)Xmalloc(sizeof(VEntry *)))) {\
+	if (!(nprev = Xmalloc(sizeof(VEntry *)))) {\
 	    Xfree(table); \
 	    return; \
         } \
@@ -954,9 +955,8 @@
 	prev = nprev;
     }
     /* now allocate the value entry */
-    entry = (VEntry)Xmalloc(((type == XrmQString) ?
-			     sizeof(VEntryRec) : sizeof(DEntryRec)) +
-			    value->size);
+    entry = Xmalloc(((type == XrmQString) ?
+		     sizeof(VEntryRec) : sizeof(DEntryRec)) + value->size);
     if (!entry)
 	return;
     entry->name = q = *quarks;
@@ -986,13 +986,12 @@
 	if (resourceQuarks) {
 	    unsigned char *prevQuarks = resourceQuarks;
 
-	    resourceQuarks = (unsigned char *)Xrealloc((char *)resourceQuarks,
-						       size);
+	    resourceQuarks = Xrealloc(resourceQuarks, size);
 	    if (!resourceQuarks) {
 		Xfree(prevQuarks);
 	    }
 	} else
-	    resourceQuarks = (unsigned char *)Xmalloc(size);
+	    resourceQuarks = Xmalloc(size);
 	if (resourceQuarks) {
 	    bzero((char *)&resourceQuarks[oldsize], size - oldsize);
 	    maxResourceQuark = (size << 3) - 1;
@@ -1135,11 +1134,11 @@
 
     str_len = strlen (str);
     if (DEF_BUFF_SIZE > str_len) lhs = lhs_s;
-    else if ((lhs = (char*) Xmalloc (str_len)) == NULL)
+    else if ((lhs = Xmalloc (str_len)) == NULL)
 	return;
 
     alloc_chars = DEF_BUFF_SIZE < str_len ? str_len : DEF_BUFF_SIZE;
-    if ((rhs = (char*) Xmalloc (alloc_chars)) == NULL) {
+    if ((rhs = Xmalloc (alloc_chars)) == NULL) {
 	if (lhs != lhs_s) Xfree (lhs);
 	return;
     }
@@ -1594,11 +1593,12 @@
      */
     {
 	struct stat status_buffer;
-	if ( (fstat(fd, &status_buffer)) == -1 ) {
+	if ( ((fstat(fd, &status_buffer)) == -1 ) ||
+             (status_buffer.st_size >= INT_MAX) ) {
 	    close (fd);
 	    return (char *)NULL;
 	} else
-	    size = status_buffer.st_size;
+	    size = (int) status_buffer.st_size;
     }
 
     if (!(filebuf = Xmalloc(size + 1))) { /* leave room for '\0' */
Index: libx11-1.4.99.1/src/locking.c
===================================================================
--- libx11-1.4.99.1.orig/src/locking.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/locking.c	2013-05-29 16:18:48.104182372 -0400
@@ -82,7 +82,7 @@
     struct _xthread_waiter *me;
 
     if (!(me = TlsGetValue(_X_TlsIndex))) {
-	me = (struct _xthread_waiter *)xmalloc(sizeof(struct _xthread_waiter));
+	me = xmalloc(sizeof(struct _xthread_waiter));
 	me->sem = CreateSemaphore(NULL, 0, 1, NULL);
 	me->next = NULL;
 	TlsSetValue(_X_TlsIndex, me);
@@ -249,7 +249,7 @@
 	dpy->lock->free_cvls = cvl->next;
 	dpy->lock->num_free_cvls--;
     } else {
-	cvl = (struct _XCVList *)Xmalloc(sizeof(struct _XCVList));
+	cvl = Xmalloc(sizeof(struct _XCVList));
 	if (!cvl)
 	    return NULL;
 	cvl->cv = xcondition_malloc();
@@ -510,10 +510,10 @@
 static int _XInitDisplayLock(
     Display *dpy)
 {
-    dpy->lock_fns = (struct _XLockPtrs*)Xmalloc(sizeof(struct _XLockPtrs));
+    dpy->lock_fns = Xmalloc(sizeof(struct _XLockPtrs));
     if (dpy->lock_fns == NULL)
 	return -1;
-    dpy->lock = (struct _XLockInfo *)Xmalloc(sizeof(struct _XLockInfo));
+    dpy->lock = Xmalloc(sizeof(struct _XLockInfo));
     if (dpy->lock == NULL) {
 	_XFreeDisplayLock(dpy);
 	return -1;
Index: libx11-1.4.99.1/src/pathmax.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libx11-1.4.99.1/src/pathmax.h	2013-05-29 16:18:48.104182372 -0400
@@ -0,0 +1,81 @@
+
+/***********************************************************
+
+Copyright 1987, 1988, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/*
+ * Provides a single definition of PATH_MAX instead of replicating this mess
+ * in multiple files
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <X11/Xos.h>
+
+#ifndef X_NOT_POSIX
+#ifdef _POSIX_SOURCE
+#include <limits.h>
+#else
+#define _POSIX_SOURCE
+#include <limits.h>
+#undef _POSIX_SOURCE
+#endif
+#endif
+#ifndef PATH_MAX
+#ifdef WIN32
+#define PATH_MAX 512
+#else
+#include <sys/param.h>
+#endif
+#ifndef PATH_MAX
+#ifdef MAXPATHLEN
+#define PATH_MAX MAXPATHLEN
+#else
+#define PATH_MAX 1024
+#endif
+#endif
+#endif
Index: libx11-1.4.99.1/src/udcInf.c
===================================================================
--- libx11-1.4.99.1.orig/src/udcInf.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/udcInf.c	2013-05-29 16:18:48.104182372 -0400
@@ -145,12 +145,11 @@
             if(!_XlcCompareISOLatin1(charset_str,buf)){
                 num_ret += 1;
                 if(num_ret == 1){
-                    ret = (int *)Xmalloc(sizeof(int));
+		    ret = Xmalloc(sizeof(int));
                 } else {
 		    int *prev_ret = ret;
 
-		    ret =
-                        (int *)Xrealloc(ret,num_ret*sizeof(int));
+		    ret = Xrealloc(ret, num_ret * sizeof(int));
 		    if (ret == NULL){
 			Xfree(prev_ret);
 		    }
@@ -272,7 +271,7 @@
         sprintf(buf, "fs%d.charset.udc_area", codeset-1);
         _XlcGetLocaleDataBase(lcd, "XLC_FONTSET", buf, &value, &count);
         if(count > 0){
-            udc = (_XUDCGlyphRegion *)Xmalloc(count * sizeof(_XUDCGlyphRegion));
+            udc = Xmalloc(count * sizeof(_XUDCGlyphRegion));
             if(udc == NULL){
 		_xudc_utyerrno = 0x03 ;
 		_xudc_utyerrno |= (0x0b<<8) ;
@@ -524,7 +523,7 @@
 	return(ret);
     }
 
-    crr = (_XUDCCodeRegion *)Xmalloc(num_gr*sizeof(_XUDCCodeRegion));
+    crr = Xmalloc(num_gr * sizeof(_XUDCCodeRegion));
     if(crr == NULL){
 	Xfree(gr);
 	_xudc_utyerrno = 0x03 ;
Index: libx11-1.4.99.1/src/xcb_io.c
===================================================================
--- libx11-1.4.99.1.orig/src/xcb_io.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/xcb_io.c	2013-05-29 16:18:48.104182372 -0400
@@ -19,6 +19,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
@@ -757,3 +758,19 @@
 	dpy->xcb->reply_consumed += n;
 	_XFreeReplyData(dpy, False);
 }
+
+/*
+ * Read and discard "n" 32-bit words of data
+ * Matches the units of the length field in X protocol replies, and provides
+ * a single implementation of overflow checking to avoid having to replicate
+ * those checks in every caller.
+ */
+void _XEatDataWords(Display *dpy, unsigned long n)
+{
+	if (n < ((INT_MAX - dpy->xcb->reply_consumed) >> 2))
+		dpy->xcb->reply_consumed += (n << 2);
+	else
+		/* Overflow would happen, so just eat the rest of the reply */
+		dpy->xcb->reply_consumed = dpy->xcb->reply_length;
+	_XFreeReplyData(dpy, False);
+}
Index: libx11-1.4.99.1/src/xcms/cmsColNm.c
===================================================================
--- libx11-1.4.99.1.orig/src/xcms/cmsColNm.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/xcms/cmsColNm.c	2013-05-29 16:18:48.104182372 -0400
@@ -40,6 +40,7 @@
 #include <sys/stat.h>
 #include <stdio.h>
 #include <ctype.h>
+#include <limits.h>
 #define XK_LATIN1
 #include <X11/keysymdef.h>
 #include "Cv.h"
@@ -542,7 +543,10 @@
     char *pBuf;
     char *f1;
     char *f2;
-    int i;
+    size_t i;
+
+    unsigned int numEntries = 0;
+    unsigned int sectionSize = 0;
 
     *pNumEntries = 0;
     *pSectionSize = 0;
@@ -576,26 +580,37 @@
 	    return(XcmsFailure);
 	}
 
-	(*pNumEntries)++;
+	numEntries++;
+	if (numEntries >= INT_MAX)
+	    return(XcmsFailure);
 
-	(*pSectionSize) += (i = strlen(f1)) + 1;
+	i = strlen(f1);
+	if (i >= INT_MAX - sectionSize)
+	    return(XcmsFailure);
+	sectionSize += i + 1;
 	for (; i; i--, f1++) {
 	    /* REMOVE SPACES FROM COUNT */
 	    if (isspace(*f1)) {
-		(*pSectionSize)--;
+		sectionSize--;
 	    }
 	}
 
-	(*pSectionSize) += (i = strlen(f2)) + 1;
+	i = strlen(f2);
+	if (i >= INT_MAX - sectionSize)
+	    return(XcmsFailure);
+	sectionSize += i + 1;
 	for (; i; i--, f2++) {
 	    /* REMOVE SPACES FROM COUNT */
 	    if (isspace(*f2)) {
-		(*pSectionSize)--;
+		sectionSize--;
 	    }
 	}
 
     }
 
+    *pNumEntries = (int) numEntries;
+    *pSectionSize = (int) sectionSize;
+
     return(XcmsSuccess);
 }
 
Index: libx11-1.4.99.1/src/xlibi18n/lcFile.c
===================================================================
--- libx11-1.4.99.1.orig/src/xlibi18n/lcFile.c	2013-05-29 16:18:48.108182372 -0400
+++ libx11-1.4.99.1/src/xlibi18n/lcFile.c	2013-05-29 16:18:48.104182372 -0400
@@ -54,29 +54,7 @@
 
 #define XLC_BUFSIZE 256
 
-#ifndef X_NOT_POSIX
-#ifdef _POSIX_SOURCE
-#include <limits.h>
-#else
-#define _POSIX_SOURCE
-#include <limits.h>
-#undef _POSIX_SOURCE
-#endif
-#endif
-#ifndef PATH_MAX
-#ifdef WIN32
-#define PATH_MAX 512
-#else
-#include <sys/param.h>
-#endif
-#ifndef PATH_MAX
-#ifdef MAXPATHLEN
-#define PATH_MAX MAXPATHLEN
-#else
-#define PATH_MAX 1024
-#endif
-#endif
-#endif
+#include "pathmax.h"
 
 #define NUM_LOCALEDIR	64
 
